//***********************************************************************************
//Program:					Pointy Pixel Penetration
//                          ShapeBase, Triangle and Rock class.
//Description:	            Creates Shape objects with position, rotation and movement speed.
//                          Rock and Triangle inherit from ShapeBase.
//Date:						Feb 10th 2017
//Authors:					Alexander Schneider
//Course:					CMPE2700
//Class:					CNTA02
//***********************************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Drawing;
using System.Drawing.Drawing2D;

namespace PointyPixelPenetration
{
    ////////////////////////////////
    // ShapeBase class 
    //  Moving shapes
    ///////////////////////////////
    public abstract class ShapeBase
    {
        //Center point for the shape
        public PointF _pos { get; private set; }
        //Current rotation of the shape
        protected float _rot;
        //How much the rotation increases per tick
        protected float _rotInc;
        //Movement speed on X axis
        protected float _xSpeed;
        //Movement speed on Y axis
        protected float _ySpeed;
        //Randon generator for speed/rotation/shape generation
        protected static Random s_rnd = new Random();
        //Const for the size of all the shapes.
        //Public for the outside of the class to see
        //the size of the blocks.
        public const int _tileSize = 50;

        /// //////////////////////
        /// Static method to create the GraphicsPath shape of the object.
        /// Uses amount of sides for the shape, max distance from the center and variance in distance from the center.
        /// Returns GraphicsPath of shape generated by parameters.
        /// /////////////////////
        public static GraphicsPath generateShape(int sides, float radMax, float radVariance)
        {
            //New model to store the path
            GraphicsPath model = new GraphicsPath();
            //List of points to draw the shape. 12 points is the max for an object.
            PointF[] pts = new PointF[13];
            float radius;

            //If more than 12 sides is used, throw exception.
            if (sides > 12 || sides < 3)
            {
                throw new ArgumentException("ShapeBase Argument Error: Sides must be between 3-12");
            }

            for (int i = 0; i < sides; i++)
            {
                //Gets the distance from the center point to the edge for this point. Cannot exceed
                //radMax, can only go lower.
                radius = (float)((radMax / 2) * (1 - radVariance * s_rnd.NextDouble()));

                //Generate the point with sin or cos of 2pi * (i/sides) for position.
                // sides * 1.0 to force non integer math.
                pts[i] = new PointF((float)(radius * Math.Cos(Math.PI * 2.0 * (i / (sides * 1.0))))
                                  , (float)(radius * Math.Sin(Math.PI * 2.0 * (i / (sides * 1.0)))));

                //Add the first point to the end.
                //This is here because the shape is considered to have a point at the middle,
                //and this step completes the shape.
                if (i == 0)
                    pts[sides] = pts[i];
            }

            //Make the model and return it.
            model.StartFigure();
            model.AddPolygon(pts);
            model.CloseFigure();

            return model;
        }

        /// ///////////////////
        /// Constructor for shapebase.
        /// Takes a position for the initial spot.
        /// Generates a speed from -2.5 to 2.5 and
        /// a rotation speed of -3 to 3.
        /// //////////////////
        public ShapeBase(PointF position)
        {
            _pos = position;
            _rot = 0;
            _rotInc = (float)(s_rnd.NextDouble() * 6 - 3);
            _xSpeed = (float)(s_rnd.NextDouble() * 5 - 2.5);
            _ySpeed = (float)(s_rnd.NextDouble() * 5 - 2.5);
        }
        /// ////////////////////////////
        ///Default shape is a triangle if nothing is specified.
        /// ////////////////////////////
        public virtual GraphicsPath GetPath()
        {
            return generateShape(3, 1, 0);
        }
        /// /////////////////////////
        ///Render method for the shape. Creates the shape based off the GetPath()
        /// then draws a circle showing the area the shape covers.
        /// /////////////////////////
        public virtual void Render(Color fillColor, BufferedGraphics bg)
        {         
            bg.Graphics.FillPath(new SolidBrush(fillColor), GetPath());

            //Ellipse must be centered by moving it half the size/2
            bg.Graphics.DrawEllipse(new Pen(Color.Orange), _pos.X - _tileSize / 2, _pos.Y - _tileSize / 2, _tileSize, _tileSize);
        }

        /// ///////////////////////////
        /// Moves the object based off of their movement values.
        /// Needs the width and height of their movement area.
        /// //////////////////////////
        public virtual void Tick(int width, int height)
        {
            //These two are for holding the new points of the shape.
            float newX;
            float newY;

            //Increase roation value of the shape.
            _rot += _rotInc;

            //Check position to check for bounce and make new position.
            newX = _pos.X;
            newY = _pos.Y;
            //If outside x, reverse direction and set to the bounds of the window.
            if (_pos.X > width)
            {
                _xSpeed *= (float)-1.0;
                newX = width;
            }
            else if (_pos.X < 0)
            {
                _xSpeed *= (float)-1.0;
                newX = 0;
            }
            //If outside Y, reverse direction and set to the bounds of the window.
            if (_pos.Y > height)
            {
                _ySpeed *= (float)-1.0;
                newY = height;
            }
            else if (_pos.Y < 0)
            {
                _ySpeed *= (float)-1.0;
                newY = 0;
            }
            //Sets the position to the new point.
            _pos = new PointF( newX + _xSpeed, newY + _ySpeed );
        }
    }

    /// /////////////////////////////
    /// Triangle class. Inhertics from ShapeBase class
    /// Creates a shapebase with an equillateral triangle shape.
    /// /////////////////////////////
    public class Triangle:ShapeBase
    {
        /// ///////////////////////
        ///Static readonly because every triangle has the same shape.
        ////// ///////////////////////
        public static readonly GraphicsPath _model = new GraphicsPath();

        /// ///////////////////////
        ///Static contructor to set the shape to a triangle
        ////// ///////////////////////
        static Triangle()
        {
            _model = generateShape(3, _tileSize, 0);
        }

        /// ///////////////////////
        ///Uses constructor from baseclass with no changes.
        /// ///////////////////////
        public Triangle(PointF position) : base(position) { }

        /// ///////////////////////
        /// GetPath() gets the current form the the shape,
        /// gets the triangle shape and transforms it to 
        /// in the correct rotation and translation.
        /// Returns the graphicsPath.
        /// ///////////////////////
        public override GraphicsPath GetPath()
        {
            GraphicsPath tri = (GraphicsPath)_model.Clone();

            Matrix matrice = new Matrix();

            matrice.Translate(_pos.X, _pos.Y);
            matrice.Rotate(_rot);
            tri.Transform(matrice);

            return tri;
        }
    }

    /// /////////////////////////////
    /// Rock class. Inhertics from ShapeBase class
    /// Creates a shapebase with a the shape of a rock which
    /// is defined as a shape with 4-12 sides, and a random
    /// vertex distance from the center for each point.
    /// /////////////////////////////
    public class Rock : ShapeBase
    {
        //Model for the rock to have.
        public GraphicsPath _model = new GraphicsPath();

        /// ///////////////////////
        ///Uses constructor from baseclass with no changes.
        /// ///////////////////////
        public Rock(PointF position) : base(position)
        {
            _model = generateShape(s_rnd.Next(4, 13), _tileSize, 0.5f);
        }

        /// ///////////////////////
        /// GetPath() gets the current form the the shape,
        /// gets the rock shape and transforms it to 
        /// in the correct rotation and translation.
        /// Returns the graphicsPath.
        /// ///////////////////////
        public override GraphicsPath GetPath()
        {
            GraphicsPath tri = (GraphicsPath)_model.Clone();

            Matrix matrice = new Matrix();

            matrice.Translate(_pos.X, _pos.Y);
            matrice.Rotate(_rot);

            tri.Transform(matrice);

            return tri;
        }
    }
}
